data vector<A> {}

data int {}
data bool {}
data io {}
data fail {}

def foo (-> vector<int>) {
  [1, 2]
}

def dup<A> (A -> A, A):
  -> x;
  x x

def drop<A> (A ->):
  -> _;

def both<A, B, C, D, +E> (A, B, (A -> C +E), (B -> D +E) -> C, D +E):
  -> x y f g;
  x f call
  y g call

def call<R..., S..., +E> (R..., (R... -> S... +E) -> S... +E):
  _::magic

def push_back<A> (vector<A>, A -> vector<A>):
  _::magic

def pop_back<A> (vector<A> -> optional<pair<vector<A>, A>>):
  _::magic

data pair<A, B>:
  case pair (A, B)

def from_pair<A, B> (pair<A, B> -> A, B):
  _::magic

data optional<A>:
  case none
  case some (A)

def is_some<A> (optional<A> -> bool):
  _::magic

def from_some<A> (optional<A> -> A):
  _::magic

def + (int, int -> int) { _::magic }
infix right 6 +

def - (int, int -> int) { _::magic }
infix left 6 -

def * (int, int -> int) { _::magic }
infix left 7 *

def / (int, int -> int) { _::magic }
infix left 7 /

def >= (int, int -> int) { _::magic }
def >> (int, int -> int) { _::magic }
def >>= (int, int -> int) { _::magic }
def >>> (int, int -> int) { _::magic }
def foo1 (-> int) { 1 >> 2 }
def foo2 (-> int) { 1 >>> 2 }

def sqrt (int -> int) { _::magic }

def say<a> (a -> +io) { _::magic }

def scope (-> +io) {
  1000 -> x1;
  100 -> y1;
  10
  {
    -> a1;
    (a1 + x1)
    {
      -> b1;
      b1 + y1
    } call
  } call
  say
  1000 -> x2;
  100 -> y2;
  10
  {
    -> a2;
    (a2 + y2)
    {
      -> b2;
      b2 + x2
    } call
  } call
  say
}

vocab foo::bar {

def quadratic (int, int, int -> int):
  -> a b c;
  (a + (b * b - 4 * a * c) sqrt) / (2 * a)

}

def concat<A> (vector<vector<A>> -> vector<A>) { _::magic }

def test<R..., +E> (R..., (R... -> R... +E) -> R... +E) {
  if (true) {
    -> f;
    f call
    f test
  } else {
    -> _;
  }
}

// def map<R..., A, B, +E> (R..., vector<A>, <S...> (S..., A -> S..., B +E) -> R..., vector<B> +E)
def map<A, B, +E> (vector<A>, (A -> B +E) -> vector<B> +E)
{
  -> xs f;
  xs pop_back
  dup
  if (is_some) {
    from_some from_pair
    {f map} {f call} both push_back
  } else {
    drop []
  }
}

/*
// def map<R..., A, B, +E> (R..., vector<A>, (R..., A -> R..., B +E) -> R..., vector<B> +E):
def map<A, B, +E> (vector<A>, (A -> B +E) -> vector<B> +E):
  -> xs f;
  match (xs pop_back):
    case optional::some:
      from_pair -> ys y;
      ys f map
      y f call
      push_back
    case optional::none:
      []
*/

def optional_test (-> int +fail) {
  1 optional::some
  match {
    case optional::some {
      (+ 1)
    }
    case optional::none {
      0
    }
  }
}
