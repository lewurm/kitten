data vector<A> { /* ... */ }

data int { /* ... */ }

data io { /* ... */ }

data maybe<A>:
  case nothing
  case just (A)

def + (int, int -> int) { /* ... */ }
infix right 6 +

def - (int, int -> int) { /* ... */ }
infix left 6 -

def * (int, int -> int) { /* ... */ }
infix left 7 *

def / (int, int -> int) { /* ... */ }
infix left 7 /

def sqrt (int -> int) { /* ... */ }

def say<a> (a -> +io) { /* ... */ }
def call<r..., s..., +e> (r..., (r... -> s... +e) -> s... +e) { /* ... */ }

def scope (-> +io) {
  1000 -> x1;
  100 -> y1;
  10
  {
    -> a1;
    (a1 + x1)
    {
      -> b1;
      b1 + y1
    } call
  } call
  say
  1000 -> x2;
  100 -> y2;
  10
  {
    -> a2;
    (a2 + y2)
    {
      -> b2;
      b2 + x2
    } call
  } call
  say
}

vocab foo::bar {

def quadratic (int, int, int -> int):
  -> a b c;
  (a + (b * b - 4 * a * c) sqrt) / (2 * a)

}

def map<r..., a, b, +e> (r..., vector a, <s...> (s..., a -> s..., b +e) -> r..., vector b +e) { /* ... */ }

/*

def map<a, b, +e> (vector a, (a -> b +e) -> vector b +e):
  -> $xs $f;
  $xs init_last { $f map } { $f call } both

def map<a, b, +e> (vector a, (a -> b +e) -> vector b +e):
  -> xs f;
  xs init_last { f map } { f call } both

define dup<S...,A,+E> (S..., A -> S..., A, A +E):
  ->x;
  x
  x


data maybe<T>:
  case nothing ()
  case just (T)

define hello<S...> (S...->S...+io):
  if (okay):
    "hello world"
  else:
    "goodbye world"
  say

hello
  "\
" 0b1010 blah
*/
